{
  "language": "Solidity",
  "sources": {
    "contracts/Yero.sol": {
      "content": "pragma solidity ^0.4.24;\npragma experimental ABIEncoderV2;\n\n/**\n *\n *  ;.  ;.                           \n *  ; | ; |          ||          .-.  \n *  `.| `.| ....     ||  .---.  _|_ \\ \n *  |   | `=.`''===.' '.___.' (_)  \n *\n * The following algorithm is amazing, and I would like to thank Matt Hall and John Watkinson for their astounding work\n * The algorithm have been made for Autoglyphs and have been changed by dsi for Yero\n *\n * MODIFICATIONS\n * Split the contract into multiple part like MainContract, ERC721 and ERC721Receiver.\n * Add a dynamic variable `block.number` inside the `draw` function to make it more dynamic\n * Split the `draw` function into two functions with `getSymbol` and add a struct to avoid Error: Stack Too Deep.\n * Doesn't execute the `draw` function on minting and instead save the seed and the block.number to execute it on a view function (`tokenURI`)\n * Add `saveTokenURI` to save block.number into an array linked to the tokenId\n * Add `setTokenIdDefaultIndex` to change the default returned URI from the `tokenURI` function\n * Add `viewCurrentTokenURI` to view the tokenURI at the current block\n * Add `viewSpecificTokenURI` to view already saved tokenURI\n *\n *\n * FUNCTIONNING\n * The output of the 'tokenURI' function is a set of instructions to make a drawing.\n * Each symbol in the output corresponds to a cell, and there are 64x64 cells arranged in a square grid.\n * The drawing can be any size, and the pen's stroke width should be between 1/5th to 1/10th the size of a cell.\n * The drawing instructions for the nine different symbols are as follows:\n *\n *   .  Draw nothing in the cell.\n *   O  Draw a circle bounded by the cell.\n *   +  Draw centered lines vertically and horizontally the length of the cell.\n *   X  Draw diagonal lines connecting opposite corners of the cell.\n *   |  Draw a centered vertical line the length of the cell.\n *   -  Draw a centered horizontal line the length of the cell.\n *   \\  Draw a line connecting the top left corner of the cell to the bottom right corner.\n *   /  Draw a line connecting the bottom left corner of teh cell to the top right corner.\n *   #  Fill in the cell completely.\n *\n */\n\nimport { ERC721 } from \"./ERC721.sol\";\n\ncontract Yero is ERC721 {\n\n    uint public constant TOKEN_LIMIT = 512; // 8 for testing, 256 or 512 for prod;\n    uint public constant CYBERDAO_LIMIT = 15;\n\n    uint public constant FIRST_PRICE = 60606000000000000 wei; // 0.060606 ether\n    uint public constant SECOND_PRICE = 90909000000000000 wei; // 0.090909 ether\n    uint public constant THIRD_PRICE = 101010100000000000 wei; // 0.1010101 ether\n    uint public constant FOURTH_PRICE = 121212100000000000 wei; // 0.1212121 ether\n    uint public constant FIFTH_PRICE = 131313130000000000 wei; // 0.1313131 ether\n\n    // The beneficiary is 350.org\n    address public constant BENEFICIARY = 0x945A8480d61D85ED755013169dC165574d751D1a;\n    address public constant CYBERDAO = 0x90F79bf6EB2c4f870365E785982E1f101E93b906;\n\n    string internal constant TABLE_ENCODE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    mapping (uint => address) private idToCreator;\n    mapping (uint => uint8) private idToSymbolScheme;\n\n    /**\n     * @dev A mapping from NFT ID to the seed used to make it.\n     */\n    mapping (uint256 => uint256) internal idToSeed;\n    mapping (uint256 => uint256) internal seedToId;\n    mapping (uint256 => bool) internal isGenesis;\n\n    mapping (uint256 => uint256) public tokenIdDefaultIndex;\n    mapping (uint256 => uint256[]) public blockNumberSaved;\n\n    mapping (string => bool) private passwords;\n\n    function getPasswords(string _password) public view returns(bool) {\n        return passwords[_password];\n    }\n    mapping (string => bool) internal isPassFound;\n\n    address public owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Sender is not the Owner\");\n        _;\n    }\n\n    ///////////////////\n    //// GENERATOR ////\n    ///////////////////\n\n    int constant ONE = int(0x100000000);\n    uint constant USIZE = 64;\n    int constant SIZE = int(USIZE);\n    int constant HALF_SIZE = SIZE / int(2);\n\n    int constant SCALE = int(0x1b81a81ab1a81a823);\n    int constant HALF_SCALE = SCALE / int(2);\n\n    bytes prefix = \"data:text/plain;charset=utf-8,\";\n\n    // 0x2E = .\n    // 0x4F = O\n    // 0x2B = +\n    // 0x58 = X\n    // 0x7C = |\n    // 0x2D = -\n    // 0x5C = \\\n    // 0x2F = /\n    // 0x23 = #\n\n    function abs(int n) internal pure returns (int) {\n        if (n >= 0) return n;\n        return -n;\n    }\n\n    function getScheme(uint a) internal pure returns (uint8) {\n        uint index = a % 83;\n        uint8 scheme;\n        if (index < 20) {\n            scheme = 1;\n        } else if (index < 35) {\n            scheme = 2;\n        } else if (index < 48) {\n            scheme = 3;\n        } else if (index < 59) {\n            scheme = 4;\n        } else if (index < 68) {\n            scheme = 5;\n        } else if (index < 73) {\n            scheme = 6;\n        } else if (index < 77) {\n            scheme = 7;\n        } else if (index < 80) {\n            scheme = 8;\n        } else if (index < 82) {\n            scheme = 9;\n        } else {\n            scheme = 10;\n        }\n        return scheme;\n    }\n\n    /* * ** *** ***** ******** ************* ******** ***** *** ** * */\n\n    // The following code generates art.\n\n    struct DrawingValues {\n\n        uint value;\n        uint mod;\n        bytes5 symbols;\n    }\n\n    function draw(uint _id, uint _seed, uint _blockNumber) internal view returns (string) {\n        uint a = uint(uint160(keccak256(abi.encodePacked(_seed, _blockNumber))));\n        bytes memory output = new bytes(USIZE * (USIZE + 3) + 30);\n        uint c;\n        for (c = 0; c < 30; c++) {\n            output[c] = prefix[c];\n        }\n\n        DrawingValues memory drawingValues;\n\n        int x = 0;\n        int y = 0;\n        uint v = 0;\n        drawingValues.value = 0;\n        drawingValues.mod = (a % 11) + 5;\n        drawingValues.symbols = getSymbol(_id);\n\n        for (int i = int(0); i < SIZE; i++) {\n            y = (2 * (i - HALF_SIZE) + 1);\n            if (a % 3 == 1) {\n                y = -y;\n            } else if (a % 3 == 2) {\n                y = abs(y);\n            }\n            y = y * int(a);\n            for (int j = int(0); j < SIZE; j++) {\n                x = (2 * (j - HALF_SIZE) + 1);\n                if (a % 2 == 1) {\n                    x = abs(x);\n                }\n                x = x * int(a);\n                v = uint(x * y / ONE) % drawingValues.mod;\n                if (v < 5) {\n                    drawingValues.value = uint(drawingValues.symbols[v]);\n                } else {\n                    drawingValues.value = 0x2E;\n                }\n                output[c] = byte(bytes32(drawingValues.value << 248));\n                c++;\n            }\n            output[c] = byte(0x25);\n            c++;\n            output[c] = byte(0x30);\n            c++;\n            output[c] = byte(0x41);\n            c++;\n        }\n        string memory result = string(output);\n        return result;\n    }\n\n    function getSymbol(uint id) public view returns (bytes5) {\n        bytes5 symbols;\n        uint8 symbolScheme = idToSymbolScheme[id];\n\n        if (symbolScheme == 0) {\n            revert();\n        } else if (symbolScheme == 1) {\n            symbols = 0x2E582F5C2E; // X/\\\n        } else if (symbolScheme == 2) {\n            symbols = 0x2E2B2D7C2E; // +-|\n        } else if (symbolScheme == 3) {\n            symbols = 0x2E2F5C2E2E; // /\\\n        } else if (symbolScheme == 4) {\n            symbols = 0x2E5C7C2D2F; // \\|-/\n        } else if (symbolScheme == 5) {\n            symbols = 0x2E4F7C2D2E; // O|-\n        } else if (symbolScheme == 6) {\n            symbols = 0x2E5C5C2E2E; // \\\n        } else if (symbolScheme == 7) {\n            symbols = 0x2E237C2D2B; // #|-+\n        } else if (symbolScheme == 8) {\n            symbols = 0x2E4F4F2E2E; // OO\n        } else if (symbolScheme == 9) {\n            symbols = 0x2E232E2E2E; // #\n        } else {\n            symbols = 0x2E234F2E2E; // #O\n        }\n\n        return symbols;\n    }\n\n    /* * ** *** ***** ******** ************* ******** ***** *** ** * */\n\n    function creator(uint _id) external view returns (address) {\n        return idToCreator[_id];\n    }\n\n    function symbolScheme(uint _id) external view returns (uint8) {\n        return idToSymbolScheme[_id];\n    }\n\n    function createGlyph2(uint seed, string _password) external payable returns (uint256) {\n        require(numTokens < (TOKEN_LIMIT - CYBERDAO_LIMIT), \"All token Minted\");\n        if(numTokens < 30) {\n            require(msg.value >= FIRST_PRICE, \"Payement too low\");\n        } else if(numTokens < 80) {\n            require(msg.value >= SECOND_PRICE, \"Payement too low\");\n        } else if(numTokens < 432) {\n            require(msg.value >= THIRD_PRICE, \"Payement too low\");\n        } else if(numTokens < 482) {\n            require(msg.value >= FOURTH_PRICE, \"Payement too low\");\n        } else if(numTokens < 512) {\n            require(msg.value >= FIFTH_PRICE, \"Payement too low\");\n        }\n        return _mint(msg.sender, seed, _password);\n    }\n\n    function createGlyphForCyber(uint seed, string _password) external payable returns (uint256) {\n        require(numTokens < TOKEN_LIMIT, \"All token Minted\");\n        return _mint(msg.sender, seed, _password);\n    }\n\n    /**\n     * @dev Mints a new NFT.\n     * @notice This is an internal function which should be called from user-implemented external\n     * mint function. Its purpose is to show and properly initialize data structures when using this\n     * implementation.\n     * @param _to The address that will own the minted NFT.\n     */\n    function _mint(address _to, uint seed, string memory _password) internal returns (uint256) {\n        require(_to != address(0));\n        require(seedToId[seed] == 0, \"Token already minted\");\n        uint id = numTokens + 1;\n\n        idToCreator[id] = _to;\n        idToSeed[id] = seed;\n        seedToId[seed] = id;\n        if(verifyPassword(_password)) {\n            isGenesis[id] = true;\n        }\n        uint a = uint(uint160(keccak256(abi.encodePacked(seed))));\n        idToSymbolScheme[id] = getScheme(a);\n        blockNumberSaved[id].push(block.number);\n        tokenIdDefaultIndex[id] = 0;\n        emit Generated(id, _to, block.number);\n\n        numTokens = numTokens + 1;\n        _addNFToken(_to, id);\n\n        BENEFICIARY.transfer(msg.value);\n\n        emit Transfer(address(0), _to, id);\n        return block.number;\n    }\n\n    /**\n     * @dev A distinct URI (RFC 3986) for a given NFT.\n     * @param _tokenId Id for which we want uri.\n     * @return URI of _tokenId.\n     */\n    function tokenURI(uint256 _tokenId) external view validNFToken(_tokenId) returns (string memory) {\n        uint256 _defaultIndex = tokenIdDefaultIndex[_tokenId]; \n        uint256 _defaultBlockNumber = blockNumberSaved[_tokenId][_defaultIndex];\n        uint256 _seed = idToSeed[_tokenId];\n        string memory imageURI = draw(_tokenId, _seed, _defaultBlockNumber);\n        string memory genesis = isGenesis[_tokenId] ? \"true\" : \"false\";\n        string memory json = encode(bytes(abi.encodePacked(\n            '{\"name\": \"Yero\", ', \n            '\"description\": \"Dynamic Generative Art\",', \n            '\"attributes\": [{',\n            '\"isGenesis\": \"',\n            genesis,\n            '\"}], \"image\": \"',\n            imageURI,\n            '\"}'\n        )));\n        string memory data = string(abi.encodePacked(\"data:application/json;base64,\", json));\n        return data;\n    }\n\n    /**\n     * @dev Save the block.number inside an array.\n     * @param _tokenId Id for which we want uri.\n     */\n    function saveTokenURI(uint256 _tokenId) external validNFToken(_tokenId) {\n        require(idToCreator[_tokenId] == msg.sender, \"Only owner can call\");\n        blockNumberSaved[_tokenId].push(block.number);\n    }\n\n    /**\n     * @dev Set the default index for the tokenURI.\n     * @param _tokenId Id for which we want uri.\n     * @param _defaultIndex Index of block.number used to build the tokenURI to set as default.\n     */\n    function setTokenIdDefaultIndex(uint256 _tokenId, uint256 _defaultIndex) external validNFToken(_tokenId) {\n        require(idToCreator[_tokenId] == msg.sender, \"Only owner can call\");\n\n        tokenIdDefaultIndex[_tokenId] = _defaultIndex;\n    }\n\n    /**\n     * @dev View the current tokenURI for a given tokenId at the current block.\n     * @param _tokenId Id for which we want the current uri.\n     * @return URI of _tokenId.\n     */\n    function viewCurrentTokenURI(uint256 _tokenId) external view validNFToken(_tokenId) returns (string memory) {\n        uint256 _seed = idToSeed[_tokenId];\n        return(draw(_tokenId, _seed, block.number));\n    }\n\n    /**\n     * @dev View a specific, already saved tokenURI.\n     * @param _tokenId Id for which we want uri.\n     * @param _index Index for which we want to see the tokenURI.\n     * @return URI of _tokenId.\n     */\n    function viewSpecificTokenURI(uint256 _tokenId, uint256 _index) external view returns (string memory) {\n        uint256 _seed = idToSeed[_tokenId];\n        return(draw(_tokenId, _seed, blockNumberSaved[_tokenId][_index]));\n    }\n\n    function totalBlockNumberSaved(uint256 _tokenId) external view returns(uint256) {\n        return(blockNumberSaved[_tokenId].length);\n    }\n\n    function setPasswords(string[] memory _passwords) public onlyOwner {\n        for(uint i = 0; i < _passwords.length; i++) {\n            passwords[_passwords[i]] = true;\n        }\n    }\n\n    function verifyPassword(string memory _password) public returns(bool) {\n        if(passwords[_password] && !isPassFound[_password]) {\n            isPassFound[_password] = true;\n            return true;\n        }\n        return false;\n    }\n\n    function encode(bytes memory data) internal pure returns (string memory) {\n        if (data.length == 0) return \"\";\n\n        // load the table into memory\n        string memory table = TABLE_ENCODE;\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n\n        // add some extra buffer at the end required for the writing\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            // set the actual output length\n            mstore(result, encodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 3 bytes at a time\n            for {} lt(dataPtr, endPtr) {}\n            {\n                // read 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // write 4 characters\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\n                resultPtr := add(resultPtr, 1)\n            }\n\n            // padding with '='\n            switch mod(mload(data), 3)\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\n        }\n\n        return result;\n    }\n\n}"
    },
    "contracts/ERC721.sol": {
      "content": "// SPDX-Licenser-Identifier: MIT\r\npragma solidity ^0.4.24;\r\n\r\nimport \"./interfaces/ERC721TokenReceiver.sol\";\r\n\r\ncontract ERC721 {\r\n    \r\n    event Generated(uint indexed index, address indexed a, uint256 value);\r\n\r\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\r\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\r\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\r\n    ///  may be created and assigned without emitting Transfer. At the time of\r\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when the approved address for an NFT is changed or\r\n    ///  reaffirmed. The zero address indicates there is no approved address.\r\n    ///  When a Transfer event emits, this also indicates that the approved\r\n    ///  address for that NFT (if any) is reset to none.\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when an operator is enabled or disabled for an owner.\r\n    ///  The operator can manage all NFTs of the owner.\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    bytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\r\n\r\n    /**\r\n     * @dev Mapping from owner address to mapping of operator addresses.\r\n     */\r\n    mapping (address => mapping (address => bool)) internal ownerToOperators;\r\n\r\n    /**\r\n     * @dev Mapping from NFT ID to approved address.\r\n     */\r\n    mapping (uint256 => address) internal idToApproval;\r\n\r\n    /**\r\n     * @dev A mapping from NFT ID to the address that owns it.\r\n     */\r\n    mapping (uint256 => address) internal idToOwner;\r\n\r\n    /**\r\n     * @dev Mapping from NFT ID to its index in the owner tokens list.\r\n     */\r\n    mapping(uint256 => uint256) internal idToOwnerIndex;\r\n\r\n    /**\r\n     * @dev Mapping from owner to list of owned NFT IDs.\r\n     */\r\n    mapping(address => uint256[]) internal ownerToIds;\r\n\r\n    // ERC 165\r\n    mapping(bytes4 => bool) internal supportedInterfaces;\r\n\r\n    /**\r\n     * @dev Total number of tokens.\r\n     */\r\n    uint internal numTokens = 0;\r\n\r\n    string internal nftName = \"Yero\";\r\n    string internal nftSymbol = \"áµ¹\";\r\n\r\n    /**\r\n     * @dev Contract constructor.\r\n     */\r\n    constructor() public {\r\n        supportedInterfaces[0x01ffc9a7] = true; // ERC165\r\n        supportedInterfaces[0x80ac58cd] = true; // ERC721\r\n        supportedInterfaces[0x780e9d63] = true; // ERC721 Enumerable\r\n        supportedInterfaces[0x5b5e139f] = true; // ERC721 Metadata\r\n    }\r\n\r\n        /**\r\n     * @dev Guarantees that the msg.sender is an owner or operator of the given NFT.\r\n     * @param _tokenId ID of the NFT to validate.\r\n     */\r\n    modifier canOperate(uint256 _tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender]);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Guarantees that the msg.sender is allowed to transfer NFT.\r\n     * @param _tokenId ID of the NFT to transfer.\r\n     */\r\n    modifier canTransfer(uint256 _tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(\r\n            tokenOwner == msg.sender\r\n            || idToApproval[_tokenId] == msg.sender\r\n            || ownerToOperators[tokenOwner][msg.sender]\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Guarantees that _tokenId is a valid Token.\r\n     * @param _tokenId ID of the NFT to validate.\r\n     */\r\n    modifier validNFToken(uint256 _tokenId) {\r\n        require(idToOwner[_tokenId] != address(0), \"Query for non-existant token\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if `_operator` is an approved operator for `_owner`.\r\n     * @param _owner The address that owns the NFTs.\r\n     * @param _operator The address that acts on behalf of the owner.\r\n     * @return True if approved for all, false otherwise.\r\n     */\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\r\n        return ownerToOperators[_owner][_operator];\r\n    }\r\n\r\n    /**\r\n     * @dev Enables or disables approval for a third party (\"operator\") to manage all of\r\n     * `msg.sender`'s assets. It also emits the ApprovalForAll event.\r\n     * @notice This works even if sender doesn't own any tokens at the time.\r\n     * @param _operator Address to add to the set of authorized operators.\r\n     * @param _approved True if the operators is approved, false to revoke approval.\r\n     */\r\n    function setApprovalForAll(address _operator, bool _approved) external {\r\n        ownerToOperators[msg.sender][_operator] = _approved;\r\n        emit ApprovalForAll(msg.sender, _operator, _approved);\r\n    }\r\n    \r\n      //////////////////////////\r\n     //// ERC 721 and 165  ////\r\n    //////////////////////////\r\n\r\n    /**\r\n     * @dev Function to check which interfaces are suported by this contract.\r\n     * @param _interfaceID Id of the interface.\r\n     * @return True if _interfaceID is supported, false otherwise.\r\n     */\r\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool) {\r\n        return supportedInterfaces[_interfaceID];\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the target address is a contract.\r\n     * @param _addr Address to check.\r\n     * @return True if _addr is a contract, false if not.\r\n     */\r\n    function isContract(address _addr) internal view returns (bool addressCheck) {\r\n        uint256 size;\r\n        assembly { size := extcodesize(_addr) } // solhint-disable-line\r\n        addressCheck = size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers the ownership of an NFT from one address to another address. This function can\r\n     * be changed to payable.\r\n     * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\r\n     * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\r\n     * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\r\n     * function checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n     * `onERC721Received` on `_to` and throws if the return value is not\r\n     * `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\r\n     * @param _from The current owner of the NFT.\r\n     * @param _to The new owner.\r\n     * @param _tokenId The NFT to transfer.\r\n     * @param _data Additional data with no specified format, sent in call to `_to`.\r\n     */\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) external {\r\n        _safeTransferFrom(_from, _to, _tokenId, _data);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers the ownership of an NFT from one address to another address. This function can\r\n     * be changed to payable.\r\n     * @notice This works identically to the other function with an extra data parameter, except this\r\n     * function just sets data to \"\"\r\n     * @param _from The current owner of the NFT.\r\n     * @param _to The new owner.\r\n     * @param _tokenId The NFT to transfer.\r\n     */\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external {\r\n        _safeTransferFrom(_from, _to, _tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\r\n     * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\r\n     * address. Throws if `_tokenId` is not a valid NFT. This function can be changed to payable.\r\n     * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\r\n     * they maybe be permanently lost.\r\n     * @param _from The current owner of the NFT.\r\n     * @param _to The new owner.\r\n     * @param _tokenId The NFT to transfer.\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external canTransfer(_tokenId) validNFToken(_tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(tokenOwner == _from);\r\n        require(_to != address(0));\r\n        _transfer(_to, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Set or reaffirm the approved address for an NFT. This function can be changed to payable.\r\n     * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\r\n     * the current NFT owner, or an authorized operator of the current owner.\r\n     * @param _approved Address to be approved for the given NFT ID.\r\n     * @param _tokenId ID of the token to be approved.\r\n     */\r\n    function approve(address _approved, uint256 _tokenId) external canOperate(_tokenId) validNFToken(_tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(_approved != tokenOwner);\r\n        idToApproval[_tokenId] = _approved;\r\n        emit Approval(tokenOwner, _approved, _tokenId);\r\n    }\r\n\r\n        /**\r\n     * @dev Actually perform the safeTransferFrom.\r\n     * @param _from The current owner of the NFT.\r\n     * @param _to The new owner.\r\n     * @param _tokenId The NFT to transfer.\r\n     * @param _data Additional data with no specified format, sent in call to `_to`.\r\n     */\r\n    function _safeTransferFrom(address _from,  address _to,  uint256 _tokenId,  bytes memory _data) private canTransfer(_tokenId) validNFToken(_tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(tokenOwner == _from);\r\n        require(_to != address(0));\r\n\r\n        _transfer(_to, _tokenId);\r\n\r\n        if (isContract(_to)) {\r\n            bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\r\n            require(retval == MAGIC_ON_ERC721_RECEIVED);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Actually preforms the transfer.\r\n     * @notice Does NO checks.\r\n     * @param _to Address of a new owner.\r\n     * @param _tokenId The NFT that is being transferred.\r\n     */\r\n    function _transfer(address _to, uint256 _tokenId) internal {\r\n        address from = idToOwner[_tokenId];\r\n        _clearApproval(_tokenId);\r\n\r\n        _removeNFToken(from, _tokenId);\r\n        _addNFToken(_to, _tokenId);\r\n\r\n        emit Transfer(from, _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Assigns a new NFT to an address.\r\n     * @notice Use and override this function with caution. Wrong usage can have serious consequences.\r\n     * @param _to Address to which we want to add the NFT.\r\n     * @param _tokenId Which NFT we want to add.\r\n     */\r\n    function _addNFToken(address _to, uint256 _tokenId) internal {\r\n        require(idToOwner[_tokenId] == address(0));\r\n        idToOwner[_tokenId] = _to;\r\n\r\n        uint256 length = ownerToIds[_to].push(_tokenId);\r\n        idToOwnerIndex[_tokenId] = length - 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a NFT from an address.\r\n     * @notice Use and override this function with caution. Wrong usage can have serious consequences.\r\n     * @param _from Address from wich we want to remove the NFT.\r\n     * @param _tokenId Which NFT we want to remove.\r\n     */\r\n    function _removeNFToken(address _from, uint256 _tokenId) internal {\r\n        require(idToOwner[_tokenId] == _from);\r\n        delete idToOwner[_tokenId];\r\n\r\n        uint256 tokenToRemoveIndex = idToOwnerIndex[_tokenId];\r\n        uint256 lastTokenIndex = ownerToIds[_from].length - 1;\r\n\r\n        if (lastTokenIndex != tokenToRemoveIndex) {\r\n            uint256 lastToken = ownerToIds[_from][lastTokenIndex];\r\n            ownerToIds[_from][tokenToRemoveIndex] = lastToken;\r\n            idToOwnerIndex[lastToken] = tokenToRemoveIndex;\r\n        }\r\n\r\n        ownerToIds[_from].length--;\r\n    }\r\n    \r\n    /**\r\n     * @dev Clears the current approval of a given NFT ID.\r\n     * @param _tokenId ID of the NFT to be transferred.\r\n     */\r\n    function _clearApproval(uint256 _tokenId) private {\r\n        if (idToApproval[_tokenId] != address(0)) {\r\n            delete idToApproval[_tokenId];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get the approved address for a single NFT.\r\n     * @notice Throws if `_tokenId` is not a valid NFT.\r\n     * @param _tokenId ID of the NFT to query the approval of.\r\n     * @return Address that _tokenId is approved for.\r\n     */\r\n    function getApproved(uint256 _tokenId) external view validNFToken(_tokenId) returns (address) {\r\n        return idToApproval[_tokenId];\r\n    }\r\n\r\n        /**\r\n     * @dev Helper function that gets NFT count of owner. This is needed for overriding in enumerable\r\n     * extension to remove double storage (gas optimization) of owner nft count.\r\n     * @param _owner Address for whom to query the count.\r\n     * @return Number of _owner NFTs.\r\n     */\r\n    function _getOwnerNFTCount(address _owner) internal view returns (uint256) {\r\n        return ownerToIds[_owner].length;\r\n    }\r\n\r\n    //// Enumerable\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return numTokens;\r\n    }\r\n\r\n    function tokenByIndex(uint256 index) public view returns (uint256) {\r\n        require(index < numTokens);\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * @dev returns the n-th NFT ID from a list of owner's tokens.\r\n     * @param _owner Token owner's address.\r\n     * @param _index Index number representing n-th token in owner's list of tokens.\r\n     * @return Token id.\r\n     */\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256) {\r\n        require(_index < ownerToIds[_owner].length);\r\n        return ownerToIds[_owner][_index];\r\n    }\r\n\r\n        /**\r\n     * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\r\n     * considered invalid, and this function throws for queries about the zero address.\r\n     * @param _owner Address for whom to query the balance.\r\n     * @return Balance of _owner.\r\n     */\r\n    function balanceOf(address _owner) external view returns (uint256) {\r\n        require(_owner != address(0));\r\n        return _getOwnerNFTCount(_owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the owner of the NFT. NFTs assigned to zero address are considered\r\n     * invalid, and queries about them do throw.\r\n     * @param _tokenId The identifier for an NFT.\r\n     * @return Address of _tokenId owner.\r\n     */\r\n    function ownerOf(uint256 _tokenId) external view returns (address _owner) {\r\n        _owner = idToOwner[_tokenId];\r\n        require(_owner != address(0));\r\n    }\r\n    \r\n    //// Metadata\r\n\r\n    /**\r\n      * @dev Returns a descriptive name for a collection of NFTokens.\r\n      * @return Representing name.\r\n      */\r\n    function name() external view returns (string memory _name) {\r\n        _name = nftName;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an abbreviated name for NFTokens.\r\n     * @return Representing symbol.\r\n     */\r\n    function symbol() external view returns (string memory _symbol) {\r\n        _symbol = nftSymbol;\r\n    }\r\n}"
    },
    "contracts/interfaces/ERC721TokenReceiver.sol": {
      "content": "pragma solidity ^0.4.24;\r\n\r\ninterface ERC721TokenReceiver\r\n{\r\n\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns(bytes4);\r\n\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}